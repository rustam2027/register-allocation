\input{../include/header}

\begin{document}

\section{Введение}

На этапе компиляции любой программы возникает проблема \textbf{распределения регистров}. % Написать конкретно когда (Во время перехода из IR в ASM?)
Многие работы рассматривают эту проблему, мы же сфокусируемся на решениях предложенных в
работах Чайтина (Chatin)\cite{chaitin1982}, Бриггса (Briggs)\cite{briggs1994}, Полетто (Poletto)\cite{poletto1999}. % Добавить ссылки на работы
Отметим что задача является NP полной (сложность задачи будет рассмотрена в секции~\ref{seg:complexity}),
и поэтому все алгоритмы описанные ниже являются эвристическими.

Существуют различные подходы к решению этой проблемы, в рассматриваемых работах есть два подхода.
Первый, через построение \textbf{графа}, этот подход был предложен еще до работ Чайтина в работах Кокка
(Cocke) в 1970\cite{cocke1970}, Ершова в 1962\cite{ershov1962}, Шварца (Schwartz) в 1973\cite{schwartz1973}. % На самом деле в своей работе чайтин говорит что до этого не было имплементации
Второй подход это \textbf{линейная аллокация}, который для распределения регистров использует не граф,
а линейное представление кода. Этот метод был предложен в работе Полетто.

\section{Постановка задачи}

В процессе компиляции программа, представленная в виде \textbf{промежуточного представления (IR)}, допускает
наличие неограниченного числа переменных. Однако реальная архитектура процессора предоставляет ограниченное
количество регистров. Это ставит перед компилятором задачу корректного распределения переменных по имеющимся
регистрам, при недостатке регистров необходимо некоторые переменные разместить в памяти. % Показать в какой конкретно?

Для понимания задачи рассмотрим пример: программа содержит три переменные, в то время как архитектура
процессора предусматривает лишь 2 регистра. В этом случае однозначно распределить переменные по регистрам
не получится. Возникает необходимость проводить \textbf{выгрузку} (в англоязычной литературе \textit{spill})
какой-то из переменных в память. При обращении к этой переменной потребуется загрузить
её из памяти, а при изменении — снова сохранить обратно.

Таким образом важно не только обеспечить корректность выполнения программы, но и минимизировать количество обращений к памяти.
Поскольку в настоящее время скорость работы с регистрами может отличаться от скорости работы с внешней памятью на порядки.

\section{Определение сложности задачи} % Дополнить

\label{seg:complexity}

Для того чтобы показать, что задача является \textbf{NP трудной}, необходимо построить полиномиальную редукцию
для некоторой NP полной задачи, а так же показать что решение задачи позволяет получить решение некоторой
NP полной задачи.

Сначала введем некоторые определения.

% Как будто не понятно причем тут графы, нужно как-то пояснить что выбор кандидатов на спил
% и все остальное в данный момент нас не интерисует. То есть сейчас мы знаем что регистры можно распределить

\begin{definition}

    \label{def:liveness} % Мне все равно не очень нравится это определение

    Представим исходный код в виде CFG (control flow graph).
    Будем говорить что переменная \textit{жива} в момент $\tau$, если существует путь из точки входа
    программы проходящий через точку определения, $\tau$ и использования переменной, в котором не встречается другого определения.

\end{definition}

\begin{definition}

    Будем говорить что переменные $a$ и $b$ \textit{зацеплены}, если одна из переменных жива в момент объявления
    другой переменной.

\end{definition}

\begin{definition}

    $IG(V)$ -- \textit{граф зацепленности} для множества переменных некоторой программы.
    $IG(V) = (V, E)$, где $$E = \{(a, b) \ | \  a, b \in V \land \ a \text{ и } b \text{ -- зацеплены}\}.$$

\end{definition}

Если удастся получить раскраску этого графа в n цветов, то и проблема распределения переменных по
n регистрам для этой программы будет решена.

Рассмотрим простой пример:

\begin{example}
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node at (0, 0) {\begin{tabular}{l}
                1. def a \\
                2. def b \\
                3. use(a)\\
                4. def c \\
                5. use(c)\\
                6. use(d)
            \end{tabular}};

            \draw[->, thick] (2.3, 0) -- (3, 0);
        
            \node[circle, draw] (a) at (5, 0) {a};
            \node[circle, draw] (b) at (7, 0) {b};
            \node[circle, draw] (c) at (9, 0) {c};
        
            \draw[thick] (a) -- (b);
            \draw[thick] (b) -- (c);
        \end{tikzpicture}
    \caption{Пример преобразования кода в граф}
    \label{fig:ex1}
    \end{figure}

    В графе на рисунке~\ref{fig:ex1} есть ребро $(a, b)$ потому что в момент 2 переменная $a$ \textit{жива}, но в графе нет ребра $(a, c)$
    потому что в момент 4 у переменной $a$ не найдется пути который прошел бы через использование.
\end{example}

Теперь покажем что если имеется распределение регистров, то удастся раскрасить некоторый граф.

Пусть $\text{Var}$ -- множество переменных, $\text{Reg}$ -- множество регистров.
Тогда пусть существует отображение $\varphi : \text{Var} \to REG$. При этом выполняются следующее свойство:

$$\forall a, b \in \text{Var} \text{ a и b интерферируют}  \Leftrightarrow \varphi(a) \neq \varphi(b)$$

Если построить биективное отображение $\psi: REG \to C$, где множество $C$ -- множество цветов.
То раскраска графа $IG(V)$ строится как $\zeta = \psi \circ \varphi$.

% Мысль закончилась

В своей статье Чайтин~\cite{chaitin1982} предложил следующий алгоритм построения графа из исходного кода:

\begin{enumerate}
    \item Если в графе существует вершина $\text{NODE}_i$, то в исходном коде будет объявление переменной с таким
    названием.
    \item Если в графе есть ребро $(\text{NODE}_i, \text{NODE}_j)$, то в исходном коде добавим использование переменных
    например суммирование. Так, чтобы эти переменные не могли занимать один регистр.
\end{enumerate}

Этот метод работает не всегда. Иногда требуются дополнительные конструкции например \textit{операторы ветвления},
для того чтобы проблема раскраски графа действительно свилась к проблеме распределения регистров. Рассмотрим пример когда такие
преобразования потребуются.

\begin{example}

    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node at (6.5, 0) {\begin{tabular}{l}
                1. def a \\
                2. def b \\
                3. use(a, b) \\
                4. def c \\
                5. use(a, c) \\
                6. def(d) \\
                7. use(a, d) \\
                8. use(c, d)
            \end{tabular}};

            \draw[->, thick] (4, 0) -- (5, 0);
        
            \node[circle, draw] (a) at (2, 1) {a};
            \node[circle, draw] (b) at (1, 0) {b};
            \node[circle, draw] (c) at (3, 0) {c};
            \node[circle, draw] (d) at (2, -1) {d};
        
            \draw[thick] (a) -- (b);
            \draw[thick] (a) -- (c);
            \draw[thick] (b) -- (d);
            \draw[thick] (c) -- (d);
        \end{tikzpicture}
    \caption{Пример преобразования графа в код}
    \label{fig:ex2}
    \end{figure}

    На рисунке~\ref{fig:ex2} видно, что код построенный по алгоритму который был предложен Чайтином не
    всегда соответствует изначальному графу. В этом случае в исходном коде переменные
    $a$ и $d$ интерферируют, хотя в изначальном графе ребра $(a, d)$ не было. Код построенный
    по графу из рисунка~\ref{fig:ex2} должен выглядеть как на рисунке~\ref{fig:right_ex2}.

    \begin{figure}
        \centering
        \lstset{basicstyle=\ttfamily\small, frame=single}
        \begin{lstlisting}
            01. def a
            02. if statement:
            03.     def b
            04.     use(a)
            05.     def d 
            06. else:
            07.     def c
            08.     use(a)
            09.     def d
            10. use(d)
        \end{lstlisting}
        \caption{Правильный вид исходного кода}
        \label{fig:right_ex2}
    \end{figure}
\end{example}

Алгоритм построения программы по произвольному графу: (Алгоритм под вопросом)

\begin{enumerate} %% ??
    \item Для каждой вершины исходного графа создать переменную.
    \item Если между вершинами существует ребро, то создать \texttt{if statement}, в теле
    которого объявить эти переменные и использовать таким образом, чтобы они стали зацеплены.
\end{enumerate}


\section{Статья Чайтина}

\subsection{Идея}

Чтобы распределить переменные по регистрам в статье Чайтина предлагается:

\begin{enumerate}
    \item Построить граф зацепленности.\label{chatin_algo_build_graph}
    \item \label{chatin_algo_choice}\begin{enumerate}
        \item Если есть вершина со степенью меньше $n$, убираем ее из графа, и кладем ее в стек, переходим
        к \ref{chatin_algo_choice}
        \item Если граф стал пустым, это означает, что исходный граф можно было раскрасить в $n$ цветов.
        Перейти на пункт~\ref{chatin_algo_color_assignment}
        \item В противном случае выбрать вершину, степень которой больше $n$, и \textbf{удалить} её (\textbf{выгрузить} соотвествующую переменную).
        При этом необходимо реализовать механизм выгрузки вершины из памяти перед её использованием и
        последующей загрузки обратно. После этого перейти к пункту \ref{chatin_algo_build_graph}.
        \label{chatin_algo_spill}
    \end{enumerate}

    \item Теперь можно доставать по одной вершине из стека, и присваивать ей цвет. \label{chatin_algo_color_assignment}
\end{enumerate}

Теперь разберёмся в деталях. Как строить граф зацепленности описано в разделе~\ref{seg:complexity}. Далее удалим все вершины, у
которых меньше $n$ соседей. Важно понять, что это действие никак не повлияет на \textit{хроматическое} число графа. Действительно,
если у вершины меньше $n$ соседей, всегда найдётся цвет, в который её можно покрасить.
 Это упрощает задачу, поскольку мы можем просто убрать все такие вершины.
После этого остаются только вершины, у которых $n$ или более соседей. Теперь необходимо выбрать одну из вершин для удаления. Принцип выбора,
предложенный Чайтином, следующий: для каждой вершины вычисляется значение, называемое \textbf{стоимостью выгрузки}. Сначала посчитаем количество
объявлений и использований вершины. При этом нужно учитывать вес каждого использования и объявления, равный частоте их появления.
Можно считать что если использование переменной или ее объвяление происходит в цикле, то его вес будет равен 10.
Затем для того, чтобы получить стоимость выгрузки конкретной вершины, возьмем отношение
$\frac{\textit{количество использований}}{\textit{степень вершины}}$. Теперь когда необходимо выбрать вершину для выгрузки,
выберем вершину с наименьшей стоимостью выгрузки.

Затем необходимо \textbf{перестроить} граф зацепленности, так как после добавления кода для выгрузки, граф может измениться. После этого нужно
еще раз попытаться раскрасить граф.

Рассмотрим как раскрасить граф, если известно, что его можно раскрасить в $n$ цветов. Для этого, каждый раз, когда вершина
удаляется из графа, будем помещать её в стек. Когда граф станет пустым, начнём извлекать вершины из стека по одной и выбирать
для каждой цвет так, чтобы никакая соседняя вершина не имела того же цвета. 

Это всегда возможно, так как на момент помещения вершины в стек её степень была меньше $n$, что гарантирует наличие свободного
цвета. Таким образом, мы получим корректную раскраску графа, а вместе с ней — распределение регистров.

\subsection{Проблемы в алгоритме Чайтина}

В этом алгоритме есть некоторые проблемы которые обнаружил и исправил Бриггс в своей работе~\cite{briggs1994}.
Например, алгоритм Чайтина по умолчанию считает, что если у вершины больше или $n$ соседей,
то выбрать для нее цвет не получится.
Однако это не так. 
Рассмотрим несколько примеров чтобы проблемы алгоритма стали понятны.

Первый пример это граф с рисунка~\ref{fig:ex2}. Нетрудно заметить что такой граф можно покрасить в два цвета.
Однако алгоритм Чайтина не найдет такую раскраску и выгрузит одну вершину.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw] (a) at (2, 1) {a};
        \node[circle, draw] (b) at (1, 0) {b};
        \node[circle, draw] (c) at (3, 0) {c};
        \node[circle, draw] (d) at (2, -1) {d};
        
        \draw[thick] (a) -- (b);
        \draw[thick] (a) -- (c);
        \draw[thick] (b) -- (d);
        \draw[thick] (c) -- (d);

        \draw[->, thick] (3.5, 0) -- (4.5, 0);

        \node[circle, draw] (b1) at (5, 0) {b};
        \node[circle, draw] (c1) at (7, 0) {c};
        \node[circle, draw] (d1) at (6, -1) {d};

        \draw[thick] (b1) -- (d1);
        \draw[thick] (c1) -- (d1);
    \end{tikzpicture}
\end{figure} % Нужна ли эта картинка

Еще один пример неэффективной работы алгоритма Чайтина — это алгоритм SVD разложения.
В данном алгоритме используются несколько глобальных переменных и вложенных циклов.
Проблема распределения регистров возникает именно из-за глобальных переменных.  
Однако, поскольку стоимость выгрузки глобальных переменных слишком велика, в первую очередь выгружаются переменные циклов.
Это не решает проблему, так как основная сложность связана не с переменными циклов. 
В результате некоторые регистры могут оставаться свободными, несмотря на то, что переменные циклов выгружаются в память, что ещё больше снижает эффективность работы алгоритма.

Структура кода выглядит приблизительно так:

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[above] (n) at (0, 6) {$n$};
        \draw[line width=2pt] (n) -- (0, 4);

        \node[above] (i) at (1, 5.6) {$i$};
        \draw[line width=2pt] (i) -- (1, 4.5);

        \node[above] (N) at (3, 6) {$N$};
        \draw[line width=2pt] (N) -- (3, 1);

        \node[above] (N) at (4, 6) {$M$};
        \draw[line width=2pt] (N) -- (4, 1);

        \draw[line width=2pt] (0, 3) -- (0, 1);
        \draw[line width=2pt] (1, 2.5) -- (1, 1.5);
    
        \node at (0.625, -0.5) {\Huge $\cdots$};
        \node at (3.625,-0.5) {\Huge $\cdots$};
    \end{tikzpicture}
    \caption{Структура кода}
    \label{fig:structure}
\end{figure}

В этом коде есть переменные $i$ и $n$, это переменные циклов. А так же есть переменные $N$ и $M$ это
некие глобальные переменные. Для простоты можно считать что они определяют границы циклов, при этом
в самих циклах не участвуют.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw, minimum size=1cm] (i) at (0, 0) {$i$};
        \node[circle, draw, minimum size=1cm] (n) at (0, 2) {$n$};
        \node[circle, draw, minimum size=1cm] (N) at (2, 0) {$N$};
        \node[circle, draw, minimum size=1cm] (M) at (2, 2) {$M$};
        \node[circle, draw, minimum size=1cm] (Others) at (6, 1) {\text{Другие переменные}};

        \node[below of=i] {$\frac{10}{3} \approx 3.3$};
        \node[above of=n] {$\frac{10}{3} \approx 3.3$};
        \node[below of=N] {$\frac{150}{30} = 5$};
        \node[above of=M] {$\frac{150}{30} = 5$};
        \node[above of=Others] {$\frac{100}{27} \approx 3.7$};

        \draw (i) -- (n);
        \draw (i) -- (N);
        \draw (i) -- (M);
        \draw (n) -- (N);
        \draw (n) -- (M);
        \draw (N) -- (M);

        \draw (N) -- (Others);
        \draw (M) -- (Others);
    \end{tikzpicture}
    \caption{Граф зацепленности и стоимости выгрузки}
\end{figure}

Для простоты представим, что других переменных 27 и каждая из них имеет 100 использований.
При этом $i$ и $n$ имеют 3 соседа, и используются 10 раз.
У глобальных переменных $N$ и $M$  30 соседей, и пусть из каждая из них используется 150 раз.
Будем считать что граф необходимо покрасить в 2 цвета.
Рассчитаем для каждой вершины стоимость выгрузки $\text{cost}(i) = \text{cost}(n) = \frac{10}{3} \approx 3.3$, $\text{cost}(N) = \text{cost}(M) = \frac{150}{30} = 5$,
$\text{cost}(\text{other}) = \frac{100}{27} \approx 3.7$.
Как видно в первую очередь будет производиться выгрузка переменных $i$ или $n$.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw, minimum size=1cm] (n) at (0, 2) {$n$};
        \node[circle, draw, minimum size=1cm] (N) at (2, 0) {$N$};
        \node[circle, draw, minimum size=1cm] (M) at (2, 2) {$M$};
        \node[circle, draw, minimum size=1cm] (Others) at (6, 1) {\text{Другие переменные}};
        
        \node[above of=n] {$\frac{10}{2} \approx 5$};
        \node[below of=N] {$\frac{150}{29} = 5.17$};
        \node[above of=M] {$\frac{150}{29} = 5.17$};
        \node[above of=Others] {$\frac{100}{27} \approx 3.7$};

        \draw (n) -- (N);
        \draw (n) -- (M);
        \draw (N) -- (M);

        \draw (N) -- (Others);
        \draw (M) -- (Others);
    \end{tikzpicture}
    \caption{Пересчитанные стоимости}
    \label{fig:chatin_problem_2}
\end{figure}

Пересчитаем значение стоимости выгрузки (см. Рисунок~\ref{fig:chatin_problem_2}). И снова алгоритм предлагает
выгрузить переменную $n$, переменную цикла, однако это не решит проблему.
В конце переменные $M$ и $N$ будут выгружены, как и переменные $i$ и $n$.
А так как переменные $i$ и $n$ используются в цикле, то их придется очень часто выгружать и загружать, что
значительно повлияет на производительность.

\section{Статья Бриггса}

\subsection{Анализ проблем}

В своей статье Бриггс описывает модифицированный алгоритм раскраски графа, он называет его \textbf{optimistic coloring}.
Разберем какая именно проблема скрывается в выше описанных примерах, и как можно их решить.

В примере с рисунка~\ref{fig:ex2}, как уже было сказано, алгоритм Чайтина выгрузит какую-то переменную,
хотя очевидно что обойтись можно и без этого. Эта проблема связана с тем что по умолчанию алгоритм считает,
что если есть вершина графа со степенью большей $n$, то такой граф нельзя раскрасить в $n$ цветов.

В примере SVD разложения проблема возникает не когда алгоритм выбирает сгрузить переменные $i$ и $n$, а когда
после выгрузки $N$ и $M$ он не обнаруживает что переменные $n$ и $i$ вполне могут поместиться на регистры.
Несмотря на то, что сначала казалось иначе.

\subsection{Идея}

Для решения вышеперечисленных проблем Бриггс предлагает внести следующие корректировки в алгоритм Чайтина:

\begin{enumerate}
    \item В пункте~\ref{chatin_algo_spill} алгоритма, в случае обнаружения вершины у которой больше $n$ соседей,
    не будем сразу выгружать вершину, а положим ее на стек. \label{briggs_change_spill}
    \item Соответственно в пункте \ref{chatin_algo_color_assignment} возникает проблема, ведь теперь не всегда
    вершину можно будет покрасить. В этом случае оставим их не покрашенными, это те переменные которые нужно
    выгрузить.
    
\end{enumerate}

Эти изменения помогут решить проблемы алгоритма Чайтина. Первая проблема решается в пункте \ref{briggs_change_spill}.
Теперь в примере с рисунка \ref{fig:ex2} хотя некоторая вершина и будет выбрана для выгрузки, во время этапа \ref{chatin_algo_color_assignment}
всем вершинам удастся получить цвет.

Вторая проблема также решена. Теперь несмотря на то, что переменные $i, n, M, N$ будут выгружены (можно считать что в таком
порядке), при попытке подобрать цвета для $M, N$ станет понятно что подобрать для них цвета не получится.
Поэтому переменные $i, n$ не придется выгружать.

Эвристика предыдущего алгоритма скорее отвечала на
вопрос ``имеет ли вершина $< n$ соседей?'', чем на вопрос ``можно ли подобрать цвет для этой вершины?''. Новый
алгоритм дает ответ на последний вопрос.

\section{Статья Полетто}

В этой секции рассмотрим идею, описанную в статье Полетто. В отличие от первых двух алгоритмов
этот алгоритм базируется не на раскраске графа. Этот подход основан на изучении интервалов жизни
переменных. Поскольку определение интервалов можно произвести в один проход по коду, и сам алгоритм
работает за линейное время, то этот метод работает значительно быстрее по сравнению с предыдущими.
При этом исходя из результатов предоставленных в этой статье следует что и производительность
страдает не значительно.

% Неоюходимо ввести модель системы. В нашем случае она основана на виртуальных регистрах и !live intervals!
% разделение на интервалы... Оно не совсем верно из-за того что могут быть интервалы в которыхпеременная
% как бы жива, но на деле она должна быть мертва там
\subsection{Идея}

Как уже было сказано идея базируется на интервалах жизни.

\begin{definition}
    Будем говорить что $[i, j]$ является \textbf{интервалом жизни} переменной $v$ если не существует таких
    моментов $i'$ и $j'$ что $i' < i$ и $j < j'$ и при этом переменная $v$ \textit{жива} в эти моменты.
    Интервалы жизни для переменной $a$ будем обозначать $\text{interval}_a$
\end{definition}

\begin{definition}
    Будем говорить что переменная $a$ жива в интервальном смысле в момент $\tau$, если $\tau \in \text{interval}_a$. 
\end{definition}

Стоит заметить что в интервале жизни переменной могут встречаться интервалы в которых она будет
не жива. В дальнейшем это поможет понять почему этот алгоритм не может решить проблему раскраски графа. То
есть он на сама деле не решает NP полную задачу, а лишь ее некоторое приближение.

\begin{example}
    \begin{figure}
        \centering
        \lstset{basicstyle=\ttfamily\small, frame=single}
        \begin{lstlisting}
            01. def a
            02. if statement:
            03.     use(b)
            04. else:
            05.     use(a)
        \end{lstlisting}
        \caption{Псевдокод}
        \label{fig:example_live_intervals}
    \end{figure}

    Рассмотрим пример с рисунка~\ref{fig:example_live_intervals}. В данном случае интервалы жизни переменной
    $a~\in~[1,5]$, однако в интервале $[2,3]$ переменная не жива, так как если исполнение пошло по этому потоку
    то переменная больше не будет использована.
    
\end{example}

Теперь перейдем к алгоритму. Пусть необходимо распределить переменные по $R$ регистрам. В каждый момент
времени $\tau$ есть живые в интервальном смысле переменные, предположим их $n$. В таком случае в момент $\tau$
необходимо выгрузить $n - R$ регистров. Количество живых переменных меняться только если какая-нибудь
переменная станет живой в интервальном смысле, или наоборот какая нибудь перестанет жить.
Чтобы выбрать какие переменные будут выгружены используется следующая эвристика.
Для выгрузки выбирается та переменная, чей интервал жизни позже заканчивается.

Алгоритм:
\begin{enumerate}
    \item Удалить все не живые на момент $\tau$ переменные из списка живых. \label{poleto_alg:delete_death}
    \item Добавить живые на момент $\tau$ переменные из еще не живых в список живых. На этом этапе
    возникает необходимость выгрузить некоторые переменные. \label{poleto_alg:add_alive}
\end{enumerate}

Для того чтобы удобнее отслеживать живые переменные алгоритм хранит их в массиве отсортированном по
возрастанию правой границе интервалов жизни. Аналогично список еще не живых переменных удобно хранить в массиве,
который отсортирован по возрастанию левых границ интервалов жизни.

На этапе \ref{poleto_alg:delete_death} необходимо просмотреть список живых переменных. При этом стоит отметить
что если необходимо убрать $k$ переменных, то нужно просмотреть не более $k+1$ переменной. Это происходит за счет
того что переменные отсортированы в порядке возрастания правой границы. То есть если переменная с индексом $i$
остаётся живой в момент времени $\tau$, то проверять $i + 1$ переменную нет необходимости.

На этапе \ref{poleto_alg:add_alive} необходимо просмотреть список еще не живых переменных. Аналогично
из-за того как отсортирован список, необходимо просмотреть только те переменные, которые станут живыми
в текущий момент времени.

\begin{example}
    \begin{figure}
        \centering
        \begin{tikzpicture}

            \draw[thick] (-1,5) -- (2,5);
            \draw[thick] (0,4) -- (3,4);
            \draw[thick] (1,3) -- (6,3);
            \draw[thick] (2,2) -- (5,2);
            \draw[thick] (3,1) -- (4,1);

            \draw[dashed] (-1,5) -- (-1,0);
            \draw[dashed] (0,4) -- (0,0);
            \draw[dashed] (1,3) -- (1,0);
            \draw[dashed] (2,2) -- (2,0);
            \draw[dashed] (3,1) -- (3,0);


            \node[left] at (-1,5) {\textbf{A}};
            \node[left] at (0,4) {\textbf{B}};
            \node[left] at (1,3) {\textbf{C}};
            \node[left] at (2,2) {\textbf{D}};
            \node[left] at (3,1) {\textbf{E}};


            \node[below] at (-1,0) {\textit{1}};
            \node[below] at (0,0) {\textit{2}};
            \node[below] at (1,0) {\textit{3}};
            \node[below] at (2,0) {\textit{4}};
            \node[below] at (3,0) {\textit{5}};


            \draw[thick] (-1,5.1) -- (-1,4.9);
            \draw[thick] (2,5.1) -- (2,4.9);

            \draw[thick] (0,4.1) -- (0,3.9);
            \draw[thick] (3,4.1) -- (3,3.9);

            \draw[thick] (1,3.1) -- (1,2.9);
            \draw[thick] (6,3.1) -- (6,2.9);

            \draw[thick] (2,2.1) -- (2,1.9);
            \draw[thick] (5,2.1) -- (5,1.9);

            \draw[thick] (3,1.1) -- (3,0.9);
            \draw[thick] (4,1.1) -- (4,0.9);

        \end{tikzpicture}
        \caption{Пример интервалов жизни}
        \label{fig:live_interval_example}
    \end{figure}

    Рассмотрим пример работы алгоритма линейной аллокации.
    На рисунке~\ref{fig:live_interval_example} представлены интервалы жизни
    некоторых переменных.
    Применим алгоритм линейной алокации.
    Пусть в данном случае необходимо разместить переменные на 2 регистрах.
    В момент \textit{2} живы переменные $\{\textbf{A}, \textbf{B}\}$, и они обе помещаются в регистры.
    В момент \textit{3} живы переменные $\{\textbf{A}, \textbf{B}, \textbf{C}\}$, значит необходимо принять решение о выгрузке.
    Так как у переменной $\textbf{C}$ интервал жизни заканчивается позже чем интервалы \textbf{A} и \textbf{B}, то она и будет
    выгружена.
    В момент \textit{4} переменная \textbf{A} умирает и оживает переменная \textbf{D}, то есть живы $\{\textbf{B}, \textbf{C}, \textbf{D}\}$.
    Вновь необходимо сделать выгрузку, и снова переменная \textbf{C} выбирается для выгрузки.
    В момент \textit{5} переменная \textbf{B} умирает и на регистрах освобождается место для переменной \textbf{E}.
    В результате работы алгоритма выгруженной оказалась лишь переменная \textbf{C}.
    
\end{example}

\subsection{Оценка сложности}

Пусть $V$ колличество переменных, и $R$ колличество регистров.
Тогда сложность алгоритма $\textit{O}(V \cdot R)$ если для составления массивов интервалов жизни будет использоваться
линейный поиск.
Напомним что список интервалов остортирван.
Если использовать бинарное дерево, то сложность составит $\textit{O}(V \cdot \log R)$.

\bibliography{../include/my.bib}{}

\bibliographystyle{gost2008s}

\end{document}
