\documentclass[12pt]{article}
\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}

% Для графов
\usepackage{tikz}
\usetikzlibrary{graphs}

\usepackage{transparent}

% Поддержка русского языка
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{amsfonts, amssymb}  
\usepackage{mathtools}
\usepackage{listings} % Для кода
\usepackage{float}    % Для точного позиционирования
\usepackage{hyperref}

% Настройки страницы
\oddsidemargin=-0.5cm
\setlength{\textwidth}{6.5in}
\addtolength{\voffset}{-20pt}
\addtolength{\headsep}{25pt}

\newcounter{definition}[section]
\newcounter{example}[section]

\newenvironment{definition}[1][]{\refstepcounter{definition}\par\medskip\noindent\begin{quote}
\textbf{Определение~\thedefinition. #1}\rmfamily}{\end{quote}\medskip}

\newenvironment{example}[1][]{\refstepcounter{example}\par\medskip\noindent\begin{quote}
\textbf{Пример~\theexample. #1}\rmfamily}{\end{quote}\medskip}

\begin{document}
\section{Введение}

На этапе компиляции любой программы неизбежно возникает проблема \textbf{распределения регистров}. % Написать конкретно когда (Во время перехода из IR в ASM?)
Многие работы рассматривают эту проблему, мы же сфокусируемся на решениях предложенных в
работах Чайтина (Chatin), Бриггса (Briggs), Полетто (Poletto). % Добавить ссылки на работы

Существует различные подходы к решению этой проблемы, в рассматриваемых работах есть два
подхода. Первый, через построение \textbf{графа}, этот подход был предложен еще до работ Чайтина в
работах Кокка (Cocke) в 1980, Ершова в 1971, Шварца (Schwartz) в 1973, однако именно в
работе Чайтина в 1980 была предложена \textit{реализация} этой идеи. Второй же подход это \textbf{линейная аллокация},
то есть для распределения регистров используется \textit{не граф, а линейное представление кода} при
помощи времени жизни переменных. Это упрощает работу за счет \textit{не всегда оптимального решения} задачи.

\section{Постановка задачи}
В процессе компиляции программа, представленная в виде \textbf{промежуточного представления (IR)}, предполагает
наличие \textit{неограниченного} числа регистров. Однако реальная архитектура процессора предоставляет ограниченное
их количество. Это ставит перед компилятором задачу \textit{корректного распределения} переменных по имеющимся
регистрах. При этом важно не только обеспечить \textit{правильность} выполнения программы, но и минимизировать
количество обращений к памяти для \textit{повышения её производительности}. Поскольку в настоящее время
скорость работы с регистрами может отличаться от скорости работы с \textit{внешней памятью} может отличаться на
порядки.

Для понимания задачи рассмотрим \textit{пример}: программа использует три регистра, в то время как архитектура
процессора предусматривает лишь 2 регистра. В этом случае \textit{однозначно} распределить переменные по регистрам
не получится. Возникает необходимо проводить \textbf{выгрузку} (в англоязычной литературе \textit{spill})
какой-то из переменных в память. Таким образом, при обращении к этой переменной потребуется \textit{загрузить}
её из памяти, а при изменении — снова \textit{сохранить} обратно.

Перед компилятором возникает необходимость \textit{выбора}, какие из переменных следует \textit{выгрузить}
в память. Этот выбор напрямую влияет на производительность программы: частые обращения к памяти могут
существенно замедлить её исполнение. Поэтому задача распределения регистров включает не только обеспечение
корректной работы, но и поиск \textit{оптимального решения}, минимизирующего влияние выгрузок.

\section{Определение сложности задачи} % Дополнить
\label{seg:complexity}
Для того чтобы показать, что задача является \textbf{NP трудной}, необходимо построить \textit{полиномиальную редукцию}
для некоторой \textit{NP полной} задачи, а так же показать что решение задачи позволяет получить решение некоторой
\textit{NP полной} задачи.

Сначала введем некоторые определения.

% Как будто не понятно причем тут графы, нужно как-то пояснить что выбор кандидатов на спил
% и все остальное в данный момент нас не интерисует. То есть сейчас мы знаем что регистры можно распределить

\begin{definition}
    Будем говорить что переменная \textit{жива} в момент $\tau$, если существуют моменты в программе $\tau_{\text{def}}$ и
    $\tau_{\text{use}}$ такие, что $\tau_{\text{def}} \leq \tau \leq \tau_{\text{use}}$ и в момент $\tau_{\text{def}}$ происходит
    объявление переменной, а в момент $\tau_{\text{use}}$ происходит использование переменной. И из точки программы $\tau$
    исполнение может дойти до точки $\tau_{\text{use}}$.
\end{definition}

\begin{definition}
    Будем говорить что переменные $a$ и $b$ \textit{интерферируют}, если одна из переменных жива в момент объявления
    другой переменной и их значения не совпадают.
\end{definition}

Покажем что можно построить \textbf{граф помех}. И таким образом покажем что решение нашей задачи, поможет решить
\textit{NP полную} задачу, в нашем случае задачу о \textit{раскраске графа}.

Граф помех будет строиться следующим образом.
\begin{enumerate}
    \item Все переменные исходного кода являются вершинами в этом графе.
    \item В графе существуют ребро $(a, b)$, если переменные $a$ и $b$ \textit{интерферируют} в исходном коде.
\end{enumerate}

Пусть $\text{Var}$ множество переменных, $\text{Reg}$ множество регистров, $V$ множество вершин, $E$
множество ребер такого графа, $C$ множество цветов. 
Тогда существует отображение $\varphi : \text{Var} \to V$ биективное. При этом выполняются следующее свойство:

$$\forall a, b \in \text{Var} \text{ a и b интерферируют}  \Leftrightarrow (\varphi(a), \varphi(b)) \in E$$

Предположим что у нас есть распределение регистров. То есть имеется отображение $\psi : \text{Var} \to \text{Reg}$,
такое, что $\forall a, b \in \text{Var}; \text{ если a и b интерферируют} \Rightarrow \psi(a) \neq \psi(b)$.
Для того чтобы раскрасить граф, необходимо предъявить отображение $\text{color}: V \to C$ обладающее следующим свойством:

\begin{equation}
\forall A, B \in V; (A, B) \in E \Rightarrow c(A) \neq c(B) \tag{*}
\end{equation}

Введем дополнительное отображение $\mu : \text{Reg} \to C$. Оно биективно сопоставляет регистры и цвета.

Построим требуемое отображение $c$ следующим образом:

\begin{equation*}
\forall v \in V \medspace \text{color} (v) = \mu ( \psi  ( \varphi ^ {-1}( v ) ) )
\end{equation*}

Покажем что такое отображение действительно обладает свойством *. Рассмотрим $A, B \in V$, если $(A, B) \in V$,
то переменные $\varphi ^ {-1} ( A )$ и $\varphi ^ {-1} ( B )$ интерферируют. А так как они интерферируют, то
$\psi ( \varphi ^ {-1} ( A ) ) \neq \psi ( \varphi ^ {-1} ( B ) )$. Значит под действием $\mu$ эти вершины
попадут в разные цвета. \hfill $\blacksquare$


% Доказать что из распределения регистров можно раскрасить граф

Для простоты будем считать что никакие значения переменных в наших примерах не совпадают.

Рассмотрим простой пример:

\begin{example}
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node at (0, 0) {\begin{tabular}{l}
                1. def a \\
                2. def b \\
                3. use(a)\\
                4. def c \\
                5. use(c)\\
                6. use(d)
            \end{tabular}};

            \draw[->, thick] (2.3, 0) -- (3, 0);
        
            \node[circle, draw] (a) at (5, 0) {a};
            \node[circle, draw] (b) at (7, 0) {b};
            \node[circle, draw] (c) at (9, 0) {c};
        
            \draw[thick] (a) -- (b);
            \draw[thick] (b) -- (c);
        \end{tikzpicture}
    \caption{Пример преобразования кода в граф}
    \label{fig:ex1}
    \end{figure}

    В графе на рисунке~\ref{fig:ex1} есть ребро $(a, b)$ потому что в момент 2 переменная $a$ \textit{жива}, но в графе нет ребра $(a, c)$
    потому что в момент 4 у переменной $a$ не найдется такого момента $\tau_{\text{use}}$.
\end{example}


В своей статье Чайтин предложил следующий алгоритм построения графа из исходного кода:

\begin{enumerate}
    \item Если в графе существует вершина $\text{NODE}_i$, то в исходном коде будет объявление переменной с таким
    названием.
    \item Если в графе есть ребро $(\text{NODE}_i, \text{NODE}_j)$, то в исходном коде добавим использование переменных
    например суммирование. Так, чтобы эти переменные не могли занимать один регистр.
\end{enumerate}

Видно что этот алгоритм использует немного \textit{другое} определение интерференции, однако, несложно убедиться что эти определения
совпадают

Этот метод работает не всегда. Иногда требуются дополнительные конструкции например \textit{операторы ветвления},
для того чтобы проблема раскраски графа действительно свилась к проблеме распределения регистров. Рассмотрим пример когда такие
преобразования потребуются.

\begin{example}

    \begin{figure}
        \centering
        \begin{tikzpicture}
            \node at (6.5, 0) {\begin{tabular}{l}
                1. def a \\
                2. def b \\
                3. use(a, b) \\
                4. def c \\
                5. use(a, c) \\
                6. def(d) \\
                7. use(a, d) \\
                8. use(c, d)
            \end{tabular}};

            \draw[->, thick] (4, 0) -- (5, 0);
        
            \node[circle, draw] (a) at (2, 1) {a};
            \node[circle, draw] (b) at (1, 0) {b};
            \node[circle, draw] (c) at (3, 0) {c};
            \node[circle, draw] (d) at (2, -1) {d};
        
            \draw[thick] (a) -- (b);
            \draw[thick] (a) -- (c);
            \draw[thick] (b) -- (d);
            \draw[thick] (c) -- (d);
        \end{tikzpicture}
    \caption{Пример преобразования графа в код}
    \label{fig:ex2}
    \end{figure}

    На этом примере видно, что код построенный по алгоритму который был предложен Чайтином не
    всегда соответствует изначальному графу. В этом случае в исходном коде переменные
    $a$ и $d$ интерферируют, хотя в изначальном графе ребра $(a, d)$ не было. Код построенный
    по графу из рисунка~\ref{fig:ex2} должен выглядеть как на рисунке~\ref{fig:right_ex2}.

    \begin{figure}
        \centering
        \lstset{basicstyle=\ttfamily\small, frame=single}
        \begin{lstlisting}
            01. def a
            02. if statement:
            03.     def b
            04.     use(a)
            05.     def d 
            06. else:
            07.     def c
            08.     use(a)
            09.     def d
            10. use(d)
        \end{lstlisting}
        \caption{Правильный вид исходного кода}
        \label{fig:right_ex2}
    \end{figure}
\end{example}

% Необходимо предоставить правильный алгоритм преобразования

\section{Статья Чайтина}
\subsection{Идея}
Как уже было сказано выше, идея распределения регистров при помощи построения \textit{графа помех} уже была
предложена, однако ее \textit{реализация} впервые появилась в работе Чайтина.

Чтобы распределить переменные по регистрам в статье Чайтина предлагается:

\begin{enumerate}
    \item Построить граф помех.\label{chatin_algo_build_graph}
    \item \label{chatin_algo_choice}\begin{itemize}
        \item Если граф стал пустым, это означает, что исходный граф можно было раскрасить в $n$ цветов.
        \item Если есть вершина со степенью меньше $n$, убираем ее из графа, и кладем ее в стек, переходим
        к \ref{chatin_algo_choice}
        \item В противном случае выбрать вершину, степень которой больше $n$, и \textbf{удалить} её (\textbf{выгрузить}).
        При этом необходимо реализовать механизм выгрузки вершины из памяти перед её использованием и
        последующей загрузки обратно. После этого перейти к пункту \ref{chatin_algo_build_graph}.
        \label{chatin_algo_spill}
    \end{itemize}

    \item Теперь можно доставать из стека вершину и присваивать ей некоторый цвет. \label{chatin_algo_color_assignment}
\end{enumerate}

Теперь разберёмся в деталях. Как строить граф помех описано в разделе~\ref{seg:complexity}. Далее удалим все вершины, у
которых меньше $n$ соседей. Важно понять, что это действие никак не повлияет на \textit{хроматическое} число графа. Действительно,
если у вершины меньше $n$ соседей, всегда найдётся цвет, в который её можно покрасить. Таким образом, удаление таких вершин
не изменит хроматического числа графа. Это упрощает задачу, поскольку мы можем просто убрать все такие вершины. После этого
остаются только вершины, у которых $n$ или более соседей. Теперь необходимо выбрать одну из вершин для удаления. Принцип выбора,
предложенный Чайтином, следующий: для каждой вершины вычисляется значение, называемое \textbf{стоимостью выгрузки}. Сначала посчитаем количество
объявлений и использований вершины. При этом нужно учитывать вес каждого использования и объявления, равный частоте их появления.
А затем для того, чтобы получить \textit{стоимость выгрузки} конкретной вершины, возьмем отношение
$\frac{\textit{количество использований}}{\textit{степень вершины}}$. Теперь когда необходимо выбрать вершину для выгрузки,
выберем вершину с наименьшей \textit{стоимостью выгрузки}.

Затем необходимо \textbf{перестроить} граф помех, так как после добавления кода для выгрузки, граф может \textit{измениться}. После этого нужно
еще раз попытаться раскрасить граф.

Рассмотрим, как раскрасить граф, если известно, что его можно раскрасить в $n$ цветов. Для этого, каждый раз, когда вершина
удаляется из графа, будем помещать её в стек. Когда граф станет пустым, начнём извлекать вершины из стека по одной и выбирать
для каждой цвет так, чтобы никакая соседняя вершина не имела того же цвета. 

Это всегда возможно, так как на момент помещения вершины в стек её степень была меньше $n$, что гарантирует наличие свободного
цвета. Таким образом, мы получим корректную раскраску графа, а вместе с ней — распределение регистров.

\subsection{Проблемы в алгоритме Чайтина}

В этом алгоритме есть некоторые проблемы которые обнаружил и исправил Бриггс в своей работе.
Например, алгоритм Чайтина по умолчанию считает, что если у вершины больше или $n$ соседей,
то выбрать для нее цвет не получится. Однако это не так. 
Рассмотрим несколько примеров чтобы проблемы алгоритма стали понятны.

Первый пример это граф с рисунка~\ref{fig:ex2}. Нетрудно заметить что такой граф можно покрасить в два цвета.
Однако алгоритм Чайтина не найдет такую раскраску и выгрузит одну вершину.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw] (a) at (2, 1) {a};
        \node[circle, draw] (b) at (1, 0) {b};
        \node[circle, draw] (c) at (3, 0) {c};
        \node[circle, draw] (d) at (2, -1) {d};
        
        \draw[thick] (a) -- (b);
        \draw[thick] (a) -- (c);
        \draw[thick] (b) -- (d);
        \draw[thick] (c) -- (d);

        \draw[->, thick] (3.5, 0) -- (4.5, 0);

        \node[circle, draw] (b1) at (5, 0) {b};
        \node[circle, draw] (c1) at (7, 0) {c};
        \node[circle, draw] (d1) at (6, -1) {d};

        \draw[thick] (b1) -- (d1);
        \draw[thick] (c1) -- (d1);
    \end{tikzpicture}
\end{figure} % Нужна ли эта картинка

Еще один пример неэффективной работы алгоритма Чайтина — это алгоритм SVD-разложения.
В данном алгоритме используются несколько глобальных переменных и вложенных циклов.
Проблема распределения регистров возникает именно из-за глобальных переменных.  
Однако, поскольку стоимость выгрузки глобальных переменных слишком велика, в первую очередь выгружаются переменные циклов.
Это не решает проблему, так как основная сложность связана не с переменными циклов. 
В результате некоторые регистры могут оставаться свободными, несмотря на то, что переменные циклов выгружаются в память, что ещё больше снижает эффективность работы алгоритма.

Структура кода выглядит приблизительно так:

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[above] (n) at (0, 6) {$n$};
        \draw[line width=2pt] (n) -- (0, 4);

        \node[above] (i) at (1, 5.6) {$i$};
        \draw[line width=2pt] (i) -- (1, 4.5);

        \node[above] (N) at (3, 6) {$N$};
        \draw[line width=2pt] (N) -- (3, 1);

        \node[above] (N) at (4, 6) {$M$};
        \draw[line width=2pt] (N) -- (4, 1);

        \draw[line width=2pt] (0, 3) -- (0, 1);
        \draw[line width=2pt] (1, 2.5) -- (1, 1.5);
    
        \node at (0.625, -0.5) {\Huge $\cdots$};
        \node at (3.625,-0.5) {\Huge $\cdots$};
    \end{tikzpicture}
    \caption{Структура кода}
    \label{fig:structure}
\end{figure}

В этом коде есть переменные $i$ и $n$, это переменные циклов. А так же есть переменные $N$ и $M$ это
некие глобальные переменные. Для простоты можно считать что они определяют границы циклов, при этом
в самих циклах не участвуют.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw, minimum size=1cm] (i) at (0, 0) {$i$};
        \node[circle, draw, minimum size=1cm] (n) at (0, 2) {$n$};
        \node[circle, draw, minimum size=1cm] (N) at (2, 0) {$N$};
        \node[circle, draw, minimum size=1cm] (M) at (2, 2) {$M$};
        \node[circle, draw, minimum size=1cm] (Others) at (6, 1) {\text{Другие переменные}};

        \node[below of=i] {$\frac{10}{3} \approx 3.3$};
        \node[above of=n] {$\frac{10}{3} \approx 3.3$};
        \node[below of=N] {$\frac{150}{30} = 5$};
        \node[above of=M] {$\frac{150}{30} = 5$};
        \node[above of=Others] {$\frac{100}{27} \approx 3.7$};

        \draw (i) -- (n);
        \draw (i) -- (N);
        \draw (i) -- (M);
        \draw (n) -- (N);
        \draw (n) -- (M);
        \draw (N) -- (M);

        \draw (N) -- (Others);
        \draw (M) -- (Others);
    \end{tikzpicture}
\end{figure}

Для простоты представим, что других переменных 27 и каждый из них имеет 100 исполнений.
При этом $i$ и $n$ имеют 3 соседа, и используются 10 раз.
У глобальных переменных $N$ и $M$ таким образом получается 30 соседей, и пусть их каждая из них используется 150 раз.
Будем считать что граф необходимо покрасить в 2 цвета.
Рассчитаем для каждой вершины стоимость выгрузки $\text{cost}(i) = \text{cost}(n) = \frac{10}{3} \approx 3.3$, $\text{cost}(N) = \text{cost}(M) = \frac{150}{30} = 5$,
$\text{cost}(\text{other}) = \frac{100}{27} \approx 3.7$.
Как видно в первую очередь будет производиться выгрузка переменных $i$ или $n$.

\begin{figure}[H]
    \label{fig:chatin_problem_2}
    \centering
    \begin{tikzpicture}
        \node[circle, draw, minimum size=1cm] (n) at (0, 2) {$n$};
        \node[circle, draw, minimum size=1cm] (N) at (2, 0) {$N$};
        \node[circle, draw, minimum size=1cm] (M) at (2, 2) {$M$};
        \node[circle, draw, minimum size=1cm] (Others) at (6, 1) {\text{Другие переменные}};
        
        \node[above of=n] {$\frac{10}{2} \approx 5$};
        \node[below of=N] {$\frac{150}{29} = 5.17$};
        \node[above of=M] {$\frac{150}{29} = 5.17$};
        \node[above of=Others] {$\frac{100}{27} \approx 3.7$};

        \draw (n) -- (N);
        \draw (n) -- (M);
        \draw (N) -- (M);

        \draw (N) -- (Others);
        \draw (M) -- (Others);
    \end{tikzpicture}
    \caption{Пересчитанные стоимости}
\end{figure}

Пересчитаем значение \textit{стоимости выгрузки} (см. Рисунок~\ref{fig:chatin_problem_2}). И снова алгоритм предлагает
выгрузить переменную $n$. Таким образом алгоритм вновь выбирает переменную $n$, переменную цикла, к выгрузке,
однако это снова не решит проблему. В конце переменные $M$ и $N$ будут выгружены, как и переменные $i$ и $n$.
А так как переменные $i$ и $n$ используются в цикле, то их придется очень часто выгружать и загружать, что
\textit{значительно} повлияет на производительность.

\section{Статья Бриггса}
\subsection{Анализ проблем}

В своей статье Бриггс описывает модифицированный алгоритм раскраски графа, он называет его \textbf{optimistic coloring}.
Разберем какая именно проблема скрывается в выше описанных примерах, и как можно их решить.

В примере с рисунка~\ref{fig:ex2}, как уже было сказано, алгоритм Чайтина \textit{выгрузит} какую-то переменную,
хотя очевидно что обойтись можно и без этого. Эта проблема связана с тем что по умолчанию алгоритм считает,
что если есть вершина графа со степенью большей $n$, то такой граф нельзя раскрасить в $n$ цветов.

В примере SVD разложения проблема возникает не когда алгоритм выбирает \textit{сгрузить} переменные $i$ и $n$, а когда
после выгрузки $N$ и $M$ он не обнаруживает что переменные $n$ и $i$ вполне \textit{могут поместиться} на регистры.
Несмотря на то, что сначала казалось иначе.

\subsection{Идея}

Для решения вышеперечисленных проблем Бриггс предлагает внести следующие корректировки в алгоритм Чайтина:

\begin{enumerate}
    \item В пункте~\ref{chatin_algo_spill} алгоритма, в случае обнаружения вершины у которой больше $n$ соседей,
    не будем сразу выгружать вершину, а положим ее на стек. \label{briggs_change_spill}
    \item Соответственно в пункте \ref{chatin_algo_color_assignment} возникает проблема, ведь теперь не всегда
    вершину можно будет покрасить. В этом случае оставим их не покрашенными, это те переменные которые нужно
    выгрузить.
    
\end{enumerate}

Эти изменения помогут решить проблемы алгоритма Чайтина. Первая проблема решается в пункте \ref{briggs_change_spill}.
Теперь в примере с рисунка \ref{fig:ex2} хотя некоторая вершина и будет выбрана для выгрузки, во время этапа \ref{chatin_algo_color_assignment}
всем вершинам удастся получить цвет.

Вторая проблема также решена. Теперь несмотря на то, что переменные $i, n, M, N$ будут выгружены (можно считать что в таком
порядке), при попытке подобрать цвета для $M, N$ станет понятно что подобрать для них цвета не получится.
Поэтому переменные $i, n$ не придется выгружать.

Эвристика предыдущего алгоритма скорее отвечала на
вопрос ``имеет ли вершина $< n$ соседей?'', чем на вопрос ``можно ли подобрать цвет для этой вершины?''. Новый
алгоритм дает ответ на последний вопрос.

\section{Статья Полетто}
\subsection{Идея}
\subsection{Оценка эффективности}

\end{document}
