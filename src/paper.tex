\documentclass[12pt]{article}
\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}

% Для графов
\usepackage{tikz}
\usetikzlibrary{graphs}

\usepackage{transparent}

% Поддержка русского языка
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{amsfonts, amssymb}  
\usepackage{mathtools}
\usepackage{listings} % Для кода
\usepackage{float}    % Для точного позиционирования
\usepackage{hyperref}

% Настройки страницы
\oddsidemargin=-0.5cm
\setlength{\textwidth}{6.5in}
\addtolength{\voffset}{-20pt}
\addtolength{\headsep}{25pt}


\begin{document}
\section{Введение}

На этапе компиляции любой программы неизбежно возникает проблема распределения регистров. % Написать конкретно когда (Во время перехода из IR в ASM?)
Многие работы рассматривают эту проблему, мы же сфокусируемся на решениях предложенных в
работах Чайтина (Chatin), Бриггса (Briggs), Полетто (Poletto). % Добавить ссылки на работы

Существует различные подходы к решению этой проблемы, в рассматриваемых работах есть два
подхода. Первый, через построение графа, этот подход был предложен еще до работ Чайтина в
работах Кокка (Cocke) в 1980, Ершова в 1971, Шварца (Schwartz) в 1973, однако именно в
работе Чайтина в 1980 была предложена реализация этой идеи. Второй же подход это линейная аллокация,
то есть для распределения регистров используется не граф, а линейное представление кода при
помощи времени жизни переменных. Это упрощает работу за счет не всегда верного определения
хроматического числа. % Не очень хорошо подобраны слова

\section{Постановка задачи}
Задача распределения регистров возникает, когда нужно преобразовать промежуточное представление (IR),
предполагающее наличие бесконечного числа регистров, к реальному оборудованию, где количество регистров
ограничено. Помимо того что нужно распределить переменные по регистрам так, чтобы программа выполнялась,
корректно необходимо также сделать это эффективно. То есть минимизировать количество обращений в память.

Что имеется ввиду. Рассмотрим такой пример: в программе используется 3 переменных, а на процессоре
который должен исполнить эту программу 2 регистра. То есть невозможно просто распределить переменные
по регистрам процессора, тогда необходимо проводить выгрузку (в англоязычной литературе \textit{spill})
какой-то из переменных в память. Таким образом при любом использовании этой переменной будет необходимо
производить ее выгрузку из памяти, и аналогично при любом изменении производить загрузку этой переменной.

Таким образом возникает проблема выбора тех регистров, которые нужно будет выгрузить. % Не очень

\section{Определение сложности задачи}
\label{seg:complexity}
Для того чтобы показать, что задача является NP полной необходимо показать что задача сводится к
некоторой NP полной задачи, а так же показать что некоторая NP полная задача сводится к этой
задаче. Нетрудно показать что проблема распределение регистров сводится к раскраске графа.

\begin{quote}
    \textbf{Определение.}
    Будем говорить что переменная \textit{жива} в момент $\tau$, если существуют моменты в программе $\tau_{\text{def}}$ и
    $\tau_{\text{use}}$ такие, что $\tau_{\text{def}} \leq \tau \leq \tau_{\text{use}}$ и в момент $\tau_{\text{def}}$ происходит
    объявление переменной, а в момент $\tau_{\text{use}}$ происходит использование переменной. И из точки программы $\tau$
    исполнение может дойти до точки $\tau_{\text{use}}$.
\end{quote}

\begin{quote}
    \textbf{Определение.}
    Будем говорить что переменные $a$ и $b$ \textit{интерферируют}, если одна из переменных жива в момент объявления
    другой переменной и их значения не совпадают.
\end{quote}

Граф помех будет строиться следующим образом.
\begin{enumerate}
    \item Все переменные исходного кода являются вершинами в этом графе.
    \item В графе существуют ребро $(a, b)$, если переменные $a$ и $b$ интерферируют в исходном коде.
\end{enumerate}

Для простоты будем считать что никакие значения переменных в наших примерах не совпадают

Рассмотрим простой пример:
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node at (0, 0) {\begin{tabular}{l}
            1. def a \\
            2. def b \\
            3. use(a) \\
            4. def c \\
            5. use(c) \\
            6. use(d)
        \end{tabular}};

        \draw[->, thick] (2.3, 0) -- (3, 0);
        
        \node[circle, draw] (a) at (5, 0) {a};
        \node[circle, draw] (b) at (7, 0) {b};
        \node[circle, draw] (c) at (9, 0) {c};
        
        \draw[thick] (a) -- (b);
        \draw[thick] (b) -- (c);
    \end{tikzpicture}
\caption{Пример преобразования кода в граф}
\label{fig:ex1}
\end{figure}

В графе на рисунке~\ref{fig:ex1} есть ребро $(a, b)$ потому что в момент 2 переменная $a$ жива, но в графе нет ребра $(a, c)$
потому что в момент 4 у переменной $a$ не найдется такого момента $\tau_{\text{def}}$.

В своей статье Чайтин подчеркнул что задача является NP полной. То есть, что любой граф можно свести
некоторому к исходному коду программы. Для этого построим исходный код по следующему правилу:

\begin{enumerate}
    \item Если в графе существует вершина $\text{NODE}_i$, то в исходном коде будет объявление переменной с таким
    названием.
    \item Если в графе есть ребро $(\text{NODE}_i, \text{NODE}_j)$, то в исходном коде добавим использование переменных
    например суммирование. Так, чтобы эти переменные не могли занимать один регистр.
\end{enumerate}

Видно что этот алгоритм использует немного другое определение интерференции, однако, несложно убедиться что эти определения
совпадают

Этот метод действительно работает, однако не всегда все так просто, иногда требуются дополнительные конструкции например операторы ветвления,
для того чтобы проблема раскраски графа действительно свилась к проблеме распределения регистров. Рассмотрим пример когда такие
преобразования потребуются.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node at (6.5, 0) {\begin{tabular}{l}
            1. def a \\
            2. def b \\
            3. use(a, b) \\
            4. def c \\
            5. use(a, c) \\
            6. def(d) \\
            7. use(a, d) \\
            8. use(c, d)
        \end{tabular}};

        \draw[->, thick] (4, 0) -- (5, 0);
        
        \node[circle, draw] (a) at (2, 1) {a};
        \node[circle, draw] (b) at (1, 0) {b};
        \node[circle, draw] (c) at (3, 0) {c};
        \node[circle, draw] (d) at (2, -1) {d};
        
        \draw[thick] (a) -- (b);
        \draw[thick] (a) -- (c);
        \draw[thick] (b) -- (d);
        \draw[thick] (c) -- (d);
    \end{tikzpicture}
\caption{Пример преобразования графа в код}
\label{fig:ex2}
\end{figure}

На этом примере видно, что код построенный по алгоритму который был предложен Чайтина не
всегда соответствует изначальному графу. В этом случае в исходном коде переменные
$a$ и $d$ интерферируют, хотя в изначальном графе ребра $(a, d)$ не было. Код построенный
по графу из рисунка~\ref{fig:ex2} должен выглядеть как на рисунке~\ref{fig:right_ex2}.

\begin{figure}[H]
    \centering
    \lstset{basicstyle=\ttfamily\small, frame=single}
    \begin{lstlisting}
        01. def a
        02. if statement:
        03.     def b
        04.     use(a)
        05.     def d 
        06. else:
        07.     def c
        08.     use(a)
        09.     def d
        10. use(d)
    \end{lstlisting}
    \caption{Правильный вид исходного кода}
    \label{fig:right_ex2}
\end{figure}

\section{Идея Чайтина}
Как уже было сказано выше, идея распределения регистров при помощи построения графа помех уже была
предложена. Однако ее реализация впервые появилась в работе Чайтина.

В чем заключается идея изложенная в этой статье:
\begin{enumerate}
    \item Построить граф помех.
    \item Удалить из графа все вершины, степень которых меньше $n$. Если граф стал пустым, это означает, что исходный
    граф можно было раскрасить в $n$ цветов. В противном случае выбрать вершину, степень которой больше $n$, и \textbf{удалить}
    её (\textbf{выгрузить}). При этом необходимо реализовать механизм выгрузки вершины из памяти перед её использованием и
    последующей загрузки обратно. После этого перейти к пункту $1$.
\end{enumerate}

Теперь разберёмся в деталях. Как строить граф помех описано в разделе~\ref{seg:complexity}. Далее удалим все вершины, у
которых меньше $n$ соседей. Важно понять, что это действие никак не повлияет на хроматическое число графа. Действительно,
если у вершины меньше $n$ соседей, всегда найдётся цвет, в который её можно покрасить. Таким образом, удаление таких вершин
не изменит хроматического числа графа. Это упрощает задачу, поскольку мы можем просто убрать все такие вершины. После этого
остаются только вершины, у которых $n$ или более соседей. Теперь необходимо выбрать одну из вершин для удаления. Принцип выбора
следующий: для каждой вершины вычисляется значение, называемое \textbf{стоимостью выгрузки}. Сначала посчитаем количество
объявлений и использований вершины. При этом нужно учитывать вес каждого использования и объявления, равный частоте их появления.
А затем для того, чтобы получить \textbf{стоимость выгрузки} конкретной вершины, возьмем отношение
$\frac{\textit{количество использований}}{\textit{степень вершины}}$. Теперь когда необходимо выбрать вершину для выгрузки,
выберем вершину с наименьшей \textit{стоимостью выгрузки}.

Затем необходимо перестроить граф помех, так как после добавления кода для выгрузки граф может измениться. После этого нужно
еще раз попытаться раскрасить граф.

Рассмотрим как теперь раскрасить граф, если известно, что его можно раскрасить в $n$ цветов. Для этого каждый раз когда
вершина удаляется из графа будет класть ее в стек. Когда граф окажется пуст, будем доставать по одной вершине из стека
и выбирать цвет так, чтобы никакая соседняя вершина не имела такого же цвета. Это можно сделать всегда, так как когда
эта вершина клалась на стек ее степень была меньше $n$, следовательно, найдется свободный цвет. Таким образом мы получим
раскраску графа, а вместе с ней и распределение регистров.

\begin{figure}[H]
    \centering
    \textbf{TO BE CONTINUED...}
\end{figure}
\end{document}
