\documentclass[12pt]{article}
\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}

% Для графов
\usepackage{tikz}
\usetikzlibrary{graphs}

\usepackage{transparent}

% Поддержка русского языка
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{amsfonts, amssymb}  
\usepackage{mathtools}
\usepackage{listings} % Для кода
\usepackage{float}    % Для точного позиционирования
\usepackage{hyperref}

% Настройки страницы
\oddsidemargin=-0.5cm
\setlength{\textwidth}{6.5in}
\addtolength{\voffset}{-20pt}
\addtolength{\headsep}{25pt}


\begin{document}
\section{Введение}

На этапе компиляции любой программы неизбежно возникает проблема распределения регистров. % Написать конкретно когда (Во время перехода из IR в ASM?)
Многие работы рассматривают эту проблему, мы же сфокусируемся на решениях предложенных в
работах Чайтина (Chatin), Бриггса (Briggs), Полетто (Poletto). % Добавить ссылки на работы

Существует различные подходы к решению этой проблемы, в рассматриваемых работах есть два
подхода. Первый, через построение графа, этот подход был предложен еще до работ Чайтина в
работах Кокка (Cocke) в 1980, Ершова в 1971, Шварца (Schwartz) в 1973, однако именно в
работе Чайтина в 1980 была предложена реализация этой идеи. Второй же подход это линейная аллокация,
то есть для распределения регистров используется не граф, а линейное представление кода при
помощи времени жизни переменных. Это упрощает работу за счет не всегда верного определения
хроматического числа. % Не очень хорошо подобраны слова

\section{Постановка задачи}
Задача распределения регистров возникает, когда нужно преобразовать промежуточное представление (IR),
предполагающее наличие бесконечного числа регистров, к реальному оборудованию, где количество регистров
ограничено. Помимо того что нужно распределить переменные по регистрам так, чтобы программа выполнялась,
корректно необходимо также сделать это эффективно. То есть минимизировать количество обращений в память.

Что имеется ввиду. Рассмотрим такой пример: в программе используется 3 переменных, а на процессоре
который должен исполнить эту программу 2 регистра. То есть невозможно просто распределить переменные
по регистрам процессора, тогда необходимо проводить выгрузку (в англоязычной литературе \textit{spill})
какой-то из переменных в память. Таким образом при любом использовании этой переменной будет необходимо
производить ее выгрузку из памяти, и аналогично при любом изменении производить загрузку этой переменной.

Таким образом возникает проблема выбора тех регистров, которые нужно будет выгрузить. % Не очень

\section{Определение сложности задачи}
\label{seg:complexity}
Для того чтобы показать, что задача является NP полной необходимо показать что задача сводится к
некоторой NP полной задачи, а так же показать что некоторая NP полная задача сводится к этой
задаче. Нетрудно показать что проблема распределение регистров сводится к раскраске графа.

\begin{quote}
    \textbf{Определение.}
    Будем говорить что переменная \textit{жива} в момент $\tau$, если существуют моменты в программе $\tau_{\text{def}}$ и
    $\tau_{\text{use}}$ такие, что $\tau_{\text{def}} \leq \tau \leq \tau_{\text{use}}$ и в момент $\tau_{\text{def}}$ происходит
    объявление переменной, а в момент $\tau_{\text{use}}$ происходит использование переменной. И из точки программы $\tau$
    исполнение может дойти до точки $\tau_{\text{use}}$.
\end{quote}

\begin{quote}
    \textbf{Определение.}
    Будем говорить что переменные $a$ и $b$ \textit{интерферируют}, если одна из переменных жива в момент объявления
    другой переменной и их значения не совпадают.
\end{quote}

Граф помех будет строиться следующим образом.
\begin{enumerate}
    \item Все переменные исходного кода являются вершинами в этом графе.
    \item В графе существуют ребро $(a, b)$, если переменные $a$ и $b$ интерферируют в исходном коде.
\end{enumerate}

Для простоты будем считать что никакие значения переменных в наших примерах не совпадают

Рассмотрим простой пример:
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node at (0, 0) {\begin{tabular}{l}
            1. def a \\
            2. def b \\
            3. use(a) \\
            4. def c \\
            5. use(c) \\
            6. use(d)
        \end{tabular}};

        \draw[->, thick] (2.3, 0) -- (3, 0);
        
        \node[circle, draw] (a) at (5, 0) {a};
        \node[circle, draw] (b) at (7, 0) {b};
        \node[circle, draw] (c) at (9, 0) {c};
        
        \draw[thick] (a) -- (b);
        \draw[thick] (b) -- (c);
    \end{tikzpicture}
\caption{Пример преобразования кода в граф}
\label{fig:ex1}
\end{figure}

В графе на рисунке~\ref{fig:ex1} есть ребро $(a, b)$ потому что в момент 2 переменная $a$ жива, но в графе нет ребра $(a, c)$
потому что в момент 4 у переменной $a$ не найдется такого момента $\tau_{\text{def}}$.

В своей статье Чайтин подчеркнул что задача является NP полной. То есть, что любой граф можно свести
некоторому к исходному коду программы. Для этого построим исходный код по следующему правилу:

\begin{enumerate}
    \item Если в графе существует вершина $\text{NODE}_i$, то в исходном коде будет объявление переменной с таким
    названием.
    \item Если в графе есть ребро $(\text{NODE}_i, \text{NODE}_j)$, то в исходном коде добавим использование переменных
    например суммирование. Так, чтобы эти переменные не могли занимать один регистр.
\end{enumerate}

Видно что этот алгоритм использует немного другое определение интерференции, однако, несложно убедиться что эти определения
совпадают

Этот метод действительно работает, однако не всегда все так просто, иногда требуются дополнительные конструкции например операторы ветвления,
для того чтобы проблема раскраски графа действительно свилась к проблеме распределения регистров. Рассмотрим пример когда такие
преобразования потребуются.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node at (6.5, 0) {\begin{tabular}{l}
            1. def a \\
            2. def b \\
            3. use(a, b) \\
            4. def c \\
            5. use(a, c) \\
            6. def(d) \\
            7. use(a, d) \\
            8. use(c, d)
        \end{tabular}};

        \draw[->, thick] (4, 0) -- (5, 0);
        
        \node[circle, draw] (a) at (2, 1) {a};
        \node[circle, draw] (b) at (1, 0) {b};
        \node[circle, draw] (c) at (3, 0) {c};
        \node[circle, draw] (d) at (2, -1) {d};
        
        \draw[thick] (a) -- (b);
        \draw[thick] (a) -- (c);
        \draw[thick] (b) -- (d);
        \draw[thick] (c) -- (d);
    \end{tikzpicture}
\caption{Пример преобразования графа в код}
\label{fig:ex2}
\end{figure}

На этом примере видно, что код построенный по алгоритму который был предложен Чайтина не
всегда соответствует изначальному графу. В этом случае в исходном коде переменные
$a$ и $d$ интерферируют, хотя в изначальном графе ребра $(a, d)$ не было. Код построенный
по графу из рисунка~\ref{fig:ex2} должен выглядеть как на рисунке~\ref{fig:right_ex2}.

\begin{figure}[H]
    \centering
    \lstset{basicstyle=\ttfamily\small, frame=single}
    \begin{lstlisting}
        01. def a
        02. if statement:
        03.     def b
        04.     use(a)
        05.     def d 
        06. else:
        07.     def c
        08.     use(a)
        09.     def d
        10. use(d)
    \end{lstlisting}
    \caption{Правильный вид исходного кода}
    \label{fig:right_ex2}
\end{figure}

\section{Идея Чайтина}
Как уже было сказано выше, идея распределения регистров при помощи построения графа помех уже была
предложена, однако ее реализация впервые появилась в работе Чайтина.

В чем заключается идея изложенная в этой статье:
\begin{enumerate}
    \item Построить граф помех.
    \item Удалить из графа все вершины, степень которых меньше $n$. Если граф стал пустым, это означает, что исходный
    граф можно было раскрасить в $n$ цветов. В противном случае выбрать вершину, степень которой больше $n$, и \textbf{удалить}
    её (\textbf{выгрузить}). При этом необходимо реализовать механизм выгрузки вершины из памяти перед её использованием и
    последующей загрузки обратно. После этого перейти к пункту $1$.
\end{enumerate}

Теперь разберёмся в деталях. Как строить граф помех описано в разделе~\ref{seg:complexity}. Далее удалим все вершины, у
которых меньше $n$ соседей. Важно понять, что это действие никак не повлияет на хроматическое число графа. Действительно,
если у вершины меньше $n$ соседей, всегда найдётся цвет, в который её можно покрасить. Таким образом, удаление таких вершин
не изменит хроматического числа графа. Это упрощает задачу, поскольку мы можем просто убрать все такие вершины. После этого
остаются только вершины, у которых $n$ или более соседей. Теперь необходимо выбрать одну из вершин для удаления. Принцип выбора
следующий: для каждой вершины вычисляется значение, называемое \textbf{стоимостью выгрузки}. Сначала посчитаем количество
объявлений и использований вершины. При этом нужно учитывать вес каждого использования и объявления, равный частоте их появления.
А затем для того, чтобы получить \textbf{стоимость выгрузки} конкретной вершины, возьмем отношение
$\frac{\textit{количество использований}}{\textit{степень вершины}}$. Теперь когда необходимо выбрать вершину для выгрузки,
выберем вершину с наименьшей \textit{стоимостью выгрузки}.

Затем необходимо перестроить граф помех, так как после добавления кода для выгрузки, граф может измениться. После этого нужно
еще раз попытаться раскрасить граф.

Рассмотрим, как раскрасить граф, если известно, что его можно раскрасить в $n$ цветов. Для этого, каждый раз, когда вершина
удаляется из графа, будем помещать её в стек. Когда граф станет пустым, начнём извлекать вершины из стека по одной и выбирать
для каждой цвет так, чтобы никакая соседняя вершина не имела того же цвета. 

Это всегда возможно, так как на момент помещения вершины в стек её степень была меньше $n$, что гарантирует наличие свободного
цвета. Таким образом, мы получим корректную раскраску графа, а вместе с ней — распределение регистров.

\section{Проблемы в алгоритме Чайтина}

Однако в этом алгоритме есть некоторые проблемы которые обнаружил Бриггс и исправил в своей работе.
Например, алгоритм Чайтина по умолчанию считает, что если у вершины больше или $n$ соседей, то выбрать для нее цвет не получится.
Однако это не так. 
Рассмотрим несколько примеров чтобы проблемы алгоритма стали понятны.

Первый пример это граф с рисунка~\ref{fig:ex2}. Нетрудно заметить что такой граф можно покрасить в два цвета.
Однако алгоритм Чайтина не найдет такую раскраску и выгрузит одну вершину.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw] (a) at (2, 1) {a};
        \node[circle, draw] (b) at (1, 0) {b};
        \node[circle, draw] (c) at (3, 0) {c};
        \node[circle, draw] (d) at (2, -1) {d};
        
        \draw[thick] (a) -- (b);
        \draw[thick] (a) -- (c);
        \draw[thick] (b) -- (d);
        \draw[thick] (c) -- (d);

        \draw[->, thick] (3.5, 0) -- (4.5, 0);

        \node[circle, draw] (b1) at (5, 0) {b};
        \node[circle, draw] (c1) at (7, 0) {c};
        \node[circle, draw] (d1) at (6, -1) {d};

        \draw[thick] (b1) -- (d1);
        \draw[thick] (c1) -- (d1);
    \end{tikzpicture}
\end{figure} % Нужна ли эта картинка

Еще один пример неэффективной работы алгоритма Чайтина — это алгоритм SVD-разложения.
В данном алгоритме используются несколько глобальных переменных и вложенных циклов.
Проблема распределения регистров возникает именно из-за глобальных переменных.  
Однако, поскольку стоимость выгрузки глобальных переменных слишком велика, в первую очередь выгружаются переменные циклов.
Это не решает проблему, так как основная сложность связана не с переменными циклов. 
В результате некоторые регистры могут оставаться свободными, несмотря на то, что переменные циклов выгружаются в память, что ещё больше снижает эффективность работы алгоритма.

Структура кода выглядит приблизительно так:

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[above] (n) at (0, 6) {$n$};
        \draw[line width=2pt] (n) -- (0, 4);

        \node[above] (i) at (1, 5.6) {$i$};
        \draw[line width=2pt] (i) -- (1, 4.5);

        \node[above] (N) at (3, 6) {$N$};
        \draw[line width=2pt] (N) -- (3, 1);

        \node[above] (N) at (4, 6) {$M$};
        \draw[line width=2pt] (N) -- (4, 1);

        \draw[line width=2pt] (0, 3) -- (0, 1);
        \draw[line width=2pt] (1, 2.5) -- (1, 1.5);
    
        \node at (0.625, -0.5) {\Huge $\cdots$};
        \node at (3.625,-0.5) {\Huge $\cdots$};
    \end{tikzpicture}
    \caption{Структура кода}
    \label{fig:structure}
\end{figure}

Есть несколько дешевых для выгрузки переменных $i$ и $n$, и несколько дорогих переменных $N$ и $M$.
Граф помех выглядит следующим образом.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw, minimum size=1cm] (i) at (0, 0) {$i$};
        \node[circle, draw, minimum size=1cm] (n) at (0, 2) {$n$};
        \node[circle, draw, minimum size=1cm] (N) at (2, 0) {$N$};
        \node[circle, draw, minimum size=1cm] (M) at (2, 2) {$M$};
        \node[circle, draw, minimum size=1cm] (Others) at (6, 1) {\text{Другие переменные}};

        \node[below of=i] {$\frac{10}{3} \approx 3.3$};
        \node[above of=n] {$\frac{10}{3} \approx 3.3$};
        \node[below of=N] {$\frac{150}{30} = 5$};
        \node[above of=M] {$\frac{150}{30} = 5$};
        \node[above of=Others] {$\frac{100}{27} \approx 3.7$};

        \draw (i) -- (n);
        \draw (i) -- (N);
        \draw (i) -- (M);
        \draw (n) -- (N);
        \draw (n) -- (M);
        \draw (N) -- (M);

        \draw (N) -- (Others);
        \draw (M) -- (Others);
    \end{tikzpicture}
\end{figure}

Для простоты представим, что других переменных 27 и каждый из них имеет 100 исполнений.
При этом $i$ и $n$ имеют 3 соседа, и используются 10 раз.
У глобальных переменных $N$ и $M$ таким образом получается 30 соседей, и пусть их каждая из них используется 150 раз.
Будем считать что граф необходимо покрасить в 2 цвета.
Рассчитаем для каждой вершины стоимость выгрузки $\text{cost}(i) = \text{cost}(n) = \frac{10}{3} \approx 3.3$, $\text{cost}(N) = \text{cost}(M) = \frac{150}{30} = 5$,
$\text{cost}(\text{other}) = \frac{100}{27} \approx 3.7$.
Как видно в первую очередь будет производиться выгрузка переменных $i$ или $n$.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[circle, draw, minimum size=1cm] (n) at (0, 2) {$n$};
        \node[circle, draw, minimum size=1cm] (N) at (2, 0) {$N$};
        \node[circle, draw, minimum size=1cm] (M) at (2, 2) {$M$};
        \node[circle, draw, minimum size=1cm] (Others) at (6, 1) {\text{Другие переменные}};

        \draw (n) -- (N);
        \draw (n) -- (M);
        \draw (N) -- (M);

        \draw (N) -- (Others);
        \draw (M) -- (Others);
    \end{tikzpicture}
\end{figure}


\begin{figure}[H]
    \centering
    \textbf{TO BE CONTINUED...}
\end{figure}
\end{document}
