В этой секции рассмотрим идею, описанную в статье Полетто. В отличие от первых двух алгоритмов
этот алгоритм базируется не на раскраске графа. Этот подход основан на изучении интервалов жизни
переменных. Поскольку определение интервалов можно произвести в один проход по коду, и сам алгоритм
работает за линейное время, то этот метод работает значительно быстрее по сравнению с предыдущими.
При этом исходя из результатов предоставленных в этой статье следует что и производительность
кода, порожденного таким алгоритмом, страдает не значительно.

% Неоюходимо ввести модель системы. В нашем случае она основана на виртуальных регистрах и !live intervals!
% разделение на интервалы... Оно не совсем верно из-за того что могут быть интервалы в которыхпеременная
% как бы жива, но на деле она должна быть мертва там
\subsection{Идея}

Как уже было сказано идея базируется на интервалах жизни.

(Вероятно не нужные определения)

\begin{definition}
    Будем говорить что $[i, j]$ является \textbf{интервалом жизни} переменной $v$ если не существует таких
    точек $i'$ и $j'$ в CFG что $i' < i$ и $j < j'$ и при этом переменная $v$ \textit{жива} в этих точках.
    Интервалы жизни для переменной $a$ будем обозначать $\text{interval}_a$
\end{definition}

\begin{definition}
    Будем говорить что переменная $a$ жива в интервальном смысле в точке $p$, если $p \in \text{interval}_a$. 
\end{definition}

Стоит заметить что в интервале жизни переменной могут встречаться интервалы в которых она будет
не жива. В дальнейшем это поможет понять почему этот алгоритм не может решить проблему раскраски графа.

\begin{example}
    \begin{figure}[h]
        \centering
        \lstset{basicstyle=\ttfamily\small, frame=single}
        \begin{lstlisting}
            01. def a
            02. if statement:
            03.     use(b)
            04. else:
            05.     use(a)
        \end{lstlisting}
        \caption{Псевдокод}
        \label{fig:example_live_intervals}
    \end{figure}

    Рассмотрим пример с рисунка~\ref{fig:example_live_intervals}. В данном случае интервалы жизни переменной
    $a~\in~[1,5]$, однако в интервале $[2,3]$ переменная не жива, так как если исполнение пошло по этому потоку
    то переменная больше не будет использована.
    
\end{example}

(Опять пошли моменты, переписать на точки)

Теперь перейдем к алгоритму. Пусть необходимо распределить переменные по $R$ регистрам. В каждый момент
времени $\tau$ есть живые в интервальном смысле переменные, предположим их $n$. В таком случае в момент $\tau$
необходимо выгрузить $n - R$ регистров. Количество живых переменных меняться только если какая-нибудь
переменная станет живой в интервальном смысле, или наоборот какая нибудь перестанет жить.
Чтобы выбрать, какие переменные будут выгружены используется следующая эвристика.
Для выгрузки выбирается та переменная, чей интервал жизни позже заканчивается.

Алгоритм:
\begin{enumerate}
    \item Удалить все не живые на момент $\tau$ переменные из списка живых. \label{poleto_alg:delete_death}
    \item Добавить живые на момент $\tau$ переменные из еще не живых в список живых. На этом этапе
    возникает необходимость выгрузить некоторые переменные. \label{poleto_alg:add_alive}
\end{enumerate}

Для того чтобы удобнее отслеживать живые переменные алгоритм хранит их в массиве отсортированном по
возрастанию правой границе интервалов жизни. Аналогично список еще не живых переменных удобно хранить в массиве,
который отсортирован по возрастанию левых границ интервалов жизни.

На этапе \ref{poleto_alg:delete_death} необходимо просмотреть список живых переменных. При этом стоит отметить
что если необходимо убрать $k$ переменных, то нужно просмотреть не более $k+1$ переменной. Это происходит за счет
того что переменные отсортированы в порядке возрастания правой границы. То есть если переменная с индексом $i$
остаётся живой в момент времени $\tau$, то проверять $i + 1$ переменную нет необходимости.

На этапе \ref{poleto_alg:add_alive} необходимо просмотреть список еще не живых переменных. Аналогично
из-за того как отсортирован список, необходимо просмотреть только те переменные, которые станут живыми
в текущий момент времени.

\begin{example}
    \begin{figure}
        \centering
        \begin{tikzpicture}

            \draw[thick] (-1,5) -- (2,5);
            \draw[thick] (0,4) -- (3,4);
            \draw[thick] (1,3) -- (6,3);
            \draw[thick] (2,2) -- (5,2);
            \draw[thick] (3,1) -- (4,1);

            \draw[dashed] (-1,5) -- (-1,0);
            \draw[dashed] (0,4) -- (0,0);
            \draw[dashed] (1,3) -- (1,0);
            \draw[dashed] (2,2) -- (2,0);
            \draw[dashed] (3,1) -- (3,0);


            \node[left] at (-1,5) {\textbf{A}};
            \node[left] at (0,4) {\textbf{B}};
            \node[left] at (1,3) {\textbf{C}};
            \node[left] at (2,2) {\textbf{D}};
            \node[left] at (3,1) {\textbf{E}};


            \node[below] at (-1,0) {\textit{1}};
            \node[below] at (0,0) {\textit{2}};
            \node[below] at (1,0) {\textit{3}};
            \node[below] at (2,0) {\textit{4}};
            \node[below] at (3,0) {\textit{5}};


            \draw[thick] (-1,5.1) -- (-1,4.9);
            \draw[thick] (2,5.1) -- (2,4.9);

            \draw[thick] (0,4.1) -- (0,3.9);
            \draw[thick] (3,4.1) -- (3,3.9);

            \draw[thick] (1,3.1) -- (1,2.9);
            \draw[thick] (6,3.1) -- (6,2.9);

            \draw[thick] (2,2.1) -- (2,1.9);
            \draw[thick] (5,2.1) -- (5,1.9);

            \draw[thick] (3,1.1) -- (3,0.9);
            \draw[thick] (4,1.1) -- (4,0.9);

        \end{tikzpicture}
        \caption{Пример интервалов жизни}
        \label{fig:live_interval_example}
    \end{figure}

    Рассмотрим пример работы алгоритма линейной аллокации.
    На рисунке~\ref{fig:live_interval_example} представлены интервалы жизни
    некоторых переменных.
    Применим алгоритм линейной аллокации.
    Пусть в данном случае необходимо разместить переменные на 2 регистрах.
    В момент \textit{2} живы переменные $\{\textbf{A}, \textbf{B}\}$, и они обе помещаются в регистры.
    В момент \textit{3} живы переменные $\{\textbf{A}, \textbf{B}, \textbf{C}\}$, значит необходимо принять решение о выгрузке.
    Так как у переменной $\textbf{C}$ интервал жизни заканчивается позже чем интервалы \textbf{A} и \textbf{B}, то она и будет
    выгружена.
    В момент \textit{4} переменная \textbf{A} умирает и оживает переменная \textbf{D}, то есть живы $\{\textbf{B}, \textbf{C}, \textbf{D}\}$.
    Вновь необходимо сделать выгрузку, и снова переменная \textbf{C} выбирается для выгрузки.
    В момент \textit{5} переменная \textbf{B} умирает и на регистрах освобождается место для переменной \textbf{E}.
    В результате работы алгоритма выгруженной оказалась лишь переменная \textbf{C}.
    
\end{example}

\subsection{Оценка сложности}

Пусть $V$ количество переменных, и $R$ количество регистров.
Тогда сложность алгоритма $\textit{O}(V \cdot R)$ если для составления массивов интервалов жизни будет использоваться
линейный поиск.
Напомним что список интервалов отсортирован.
Если использовать бинарное дерево, то сложность составит $\textit{O}(V \cdot \log R)$.
