В этой секции рассмотрим идею, описанную в статье Полетто. В отличие от первых двух алгоритмов
этот алгоритм базируется не на раскраске графа. Он основан на изучении интервалов жизни
переменных. Поскольку определение интервалов можно произвести в один проход по коду, и сам алгоритм
работает за линейное время, то этот метод работает значительно быстрее по сравнению с предыдущими.
При этом согласно результатам, представленным в статье, производительность кода, сгенерированного c использованием этого алгоритма,
снижается незначительно.
% Неоюходимо ввести модель системы. В нашем случае она основана на виртуальных регистрах и !live intervals!
% разделение на интервалы... Оно не совсем верно из-за того что могут быть интервалы в которыхпеременная
% как бы жива, но на деле она должна быть мертва там

\subsection{Идея}

Представим программу в некотором IR и пронумеруем его операции произвольным образом.
Например, в качестве тривиального подхода подойдет нумерация строк исходного кода программы.
Альтернативно, можно пронумеровать линейные участки в CFG, например в порядке обхода DFS.
% Например, если имеется дерево, то в качестве нумерации такого IR можно взять порядок обхода DFS.

% Рассмотреть разные принципы нумерации например CFG и просто построчный,
% сказать что построчный медленнее но эффективнее
% а CFG отлично подходит когда нужно распределить очень быстро

\begin{definition}
    \textit{Интервалом жизни} переменной $v$ будем называть отрезок $[i, j]$,
    где $i$ --- это наименьший номер точки в которой переменная жива,
    а $j$ --- наибольший.
    Интервалы жизни для переменной $a$ будем обозначать $\text{interval}_a$.
\end{definition}

\begin{definition}
    Будем говорить, что переменная $a$ \textit{жива в интервальном смысле} в точке $p$, если $p \in \text{interval}_a$. 
\end{definition}

Заметим, что в интервале жизни переменной могут встречаться точки, в которых она не жива. 

\begin{example}
    \begin{figure}[h]
        \centering
        \lstset{basicstyle=\ttfamily\small, frame=single}
        \begin{lstlisting}
            01. def a
            02. if statement:
            03.     use(b)
            04. else:
            05.     use(a)
        \end{lstlisting}
        \caption{Псевдокод}
        \label{fig:example_live_intervals}
    \end{figure}

    Рассмотрим пример с рисунка~\ref{fig:example_live_intervals}. При выбранной нумерации IR интервалы жизни переменной
    $a~\in~[1,5]$, однако в интервале $[2,3]$ переменная не жива, так как если исполнение пошло по этому пути
    то переменная больше не будет использована.
    
\end{example}

Хотя алгоритм не опирается на какую-то конкретную нумерацию,
выбор нумерации может значительно повлиять на результат аллокации.
Например, если необходимо произвести аллокацию быстро,
можно пронумеровать линейные участки CFG.
Однако при таком методе нумерации не будут учтены операции внутри линейных участков.
С другой стороны можно пронумеровать каждую операцию над переменными.
В таком случае будет играть важную роль то,
как они упорядочены.
От этого и будет зависеть количество мертвых точек внутри интервалов жизни.
В общем случае лучшей нумерацией будет топологическая сортировка.

Теперь перейдем к алгоритму. Пусть необходимо распределить переменные по $R$ регистрам. В каждой точке
$p$ есть живые в интервальном смысле переменные, предположим, их $n$. В таком случае в точке $p$
необходимо выгрузить $n - R$ регистров. Количество живых переменных меняется только если какая-нибудь
переменная станет живой в интервальном смысле или, наоборот, какая-нибудь перестанет быть живой.
Чтобы выбрать переменные для выгрузки, используется эвристика,
при которой отдается предпочтение переменной с более поздним окончанием интервала жизни.

Алгоритм, предложенный Полетто:

\begin{enumerate}
    \item Удалить переменные, умирающие в точке $p$, из списка живых.
    Это переменные, чьи интервалы жизни которых заканчиваются на $p$. \label{poleto_alg:delete_death}

    \item Добавить оживающие переменные в список живых.
    То есть те, интервалы жизни которых начинаются в точке $p$.
    На этом этапе может возникнуть необходимость выгрузить некоторые переменные. \label{poleto_alg:add_alive}

    \item Перейти к следующей точке.
\end{enumerate}

Для того чтобы удобнее отслеживать живые переменные, алгоритм хранит их в массиве, отсортированном по
возрастанию правой границе интервалов жизни. Аналогично список еще не живых переменных удобно хранить в массиве,
который отсортирован по возрастанию левых границ интервалов жизни.

На этапе \ref{poleto_alg:delete_death} необходимо просмотреть список живых переменных. При этом, стоит отметить,
что если необходимо убрать $k$ переменных, то нужно просмотреть не более $k+1$ переменной. Это происходит за счет
того, что переменные отсортированы в порядке возрастания правой границы. То есть если переменная с индексом $i$
остаётся живой в момент времени $\tau$, то проверять $i + 1$ переменную нет необходимости.

На этапе \ref{poleto_alg:add_alive} необходимо просмотреть список еще не живых переменных. Аналогично,
из-за того как отсортирован список, необходимо просмотреть те переменные, которые станут живыми
в текущий момент времени и, возможно, одну переменную, которая оживает потом.

\begin{example}
    \begin{figure}
        \centering
        \begin{tikzpicture}

            \draw[thick] (-1,5) -- (2,5);
            \draw[thick] (0,4) -- (3,4);
            \draw[thick] (1,3) -- (6,3);
            \draw[thick] (2,2) -- (5,2);
            \draw[thick] (3,1) -- (4,1);

            \draw[dashed] (-1,5) -- (-1,0);
            \draw[dashed] (0,4) -- (0,0);
            \draw[dashed] (1,3) -- (1,0);
            \draw[dashed] (2,2) -- (2,0);
            \draw[dashed] (3,1) -- (3,0);


            \node[left] at (-1,5) {\textbf{A}};
            \node[left] at (0,4) {\textbf{B}};
            \node[left] at (1,3) {\textbf{C}};
            \node[left] at (2,2) {\textbf{D}};
            \node[left] at (3,1) {\textbf{E}};


            \node[below] at (-1,0) {\textit{1}};
            \node[below] at (0,0) {\textit{2}};
            \node[below] at (1,0) {\textit{3}};
            \node[below] at (2,0) {\textit{4}};
            \node[below] at (3,0) {\textit{5}};


            \draw[thick] (-1,5.1) -- (-1,4.9);
            \draw[thick] (2,5.1) -- (2,4.9);

            \draw[thick] (0,4.1) -- (0,3.9);
            \draw[thick] (3,4.1) -- (3,3.9);

            \draw[thick] (1,3.1) -- (1,2.9);
            \draw[thick] (6,3.1) -- (6,2.9);

            \draw[thick] (2,2.1) -- (2,1.9);
            \draw[thick] (5,2.1) -- (5,1.9);

            \draw[thick] (3,1.1) -- (3,0.9);
            \draw[thick] (4,1.1) -- (4,0.9);

        \end{tikzpicture}
        \caption{Пример интервалов жизни}
        \label{fig:live_interval_example}
    \end{figure}

    Рассмотрим пример работы алгоритма линейной аллокации.
    На рисунке~\ref{fig:live_interval_example} представлены интервалы жизни
    некоторых переменных.
    Пусть в данном случае необходимо разместить переменные в двух регистрах.
    В момент \textit{2} живы переменные $\{\textbf{A}, \textbf{B}\}$, и они обе помещаются в регистры.
    В момент \textit{3} живы переменные $\{\textbf{A}, \textbf{B}, \textbf{C}\}$, значит, необходимо принять решение о выгрузке.
    Так как у переменной $\textbf{C}$ интервал жизни заканчивается позже, чем интервалы $\textbf{A}$ и $\textbf{B}$, то она и будет
    выгружена.
    В момент \textit{4} переменная $\textbf{A}$ умирает, и оживает переменная $\textbf{D}$, то есть живы $\{\textbf{B}, \textbf{C}, \textbf{D}\}$.
    Вновь необходимо сделать выгрузку, и снова переменная $\textbf{C}$ выбирается для выгрузки.
    В момент \textit{5} переменная $\textbf{B}$ умирает, и на регистрах освобождается место для переменной $\textbf{E}$.
    В результате работы алгоритма выгруженной оказалась лишь переменная $\textbf{C}$.
    
\end{example}

\subsection{Оценка сложности}

Пусть $V$ --- количество переменных, а $R$ --- количество регистров.
Тогда сложность алгоритма $\textit{O}(V \cdot R)$, если для составления массивов интервалов жизни будет использоваться
линейный поиск.
Напомним, что список интервалов отсортирован.
Если использовать бинарное дерево, то сложность составит $\textit{O}(V \cdot \log R)$.
